import path from 'path';
import fs from 'fs/promises';
import { FileItem } from '@fixtures/file';
import { app, dialog } from 'electron';
import { ProjectConfig } from '@fixtures/config';

const SETTINGS_DIR_PATH = '.tnet';
const SESSION_FILE_NAME = 'session.json';
const KEYWORDS_FILE_NAME = 'keywords.json';
const SETTINGS_FILE_NAME = 'settings.json';
const LATEST_FILE_NAME = 'latest.json';
const FILE_TEMPLATE = `<keyword name="">
### 変数・条件


### 主張

</keyword>

<details>
<summary>証明</summary>

</details>`;
const KEYWORD_REGEX = /<keyword([\s\S]*?)>([\s\S]*?)<\/keyword>/g;
const KEYWORD_NAME_REGEX = /name="([^"]*)"/;
const KEYWORD_NUMBER_CLASS_REGEX = /number-class="([^"]*)"/;
const KEYWORD_PREFIX_REGEX = /prefix="([^"]*)"/;

export const getKeywordContent = async (filePath: string, name: string): Promise<string | null> => {
  if (!filePath || !name) return null;

  try {
    const content = await readFile(filePath);
    return extractKeywordContentFromText(content, name);
  } catch (err) {
    console.error('error getting keyword content: ', err);
    return null;
  }
};

/*
keywords.json

name: path
*/

export const getNewFileTree = async (): Promise<{
  rootPath: string;
  fileTree: FileItem[];
}> => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    properties: ['openDirectory'],
    title: 'フォルダ選択',
    defaultPath: app.getPath('documents')
  });

  if (canceled) {
    return {
      rootPath: '',
      fileTree: []
    };
  } else {
    return {
      rootPath: filePaths[0],
      fileTree: await getFileTree(filePaths[0])
    };
  }
};

export const getFileTree = async (dirPath: string): Promise<FileItem[]> => {
  try {
    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    const result = await Promise.all(
      entries.map(async (entry) => {
        const fullPath = path.join(dirPath, entry.name);

        if (entry.isDirectory()) {
          try {
            const children = await getFileTree(fullPath);
            return {
              name: entry.name,
              path: fullPath,
              isDirectory: true,
              children: children
            };
          } catch {
            return {
              name: entry.name,
              path: fullPath,
              isDirectory: true,
              children: []
            };
          }
        } else {
          return {
            name: entry.name,
            path: fullPath,
            isDirectory: false
          };
        }
      })
    );

    result.sort((a, b) => {
      if (a.isDirectory && !b.isDirectory) return -1;
      if (!a.isDirectory && b.isDirectory) return 1;
      return a.name.localeCompare(b.name);
    });

    return result;
  } catch (err) {
    console.error('error occured while get file tree', err);
    throw new Error('error occured while get file tree');
  }
};

export const readFile = async (filePath: string): Promise<string> => {
  try {
    return await fs.readFile(filePath, 'utf-8');
  } catch (err) {
    console.error('error reading file: ', err);
    throw new Error('error reading file');
  }
};

const extractKeywordContentFromText = (content: string, name: string): string | null => {
  KEYWORD_REGEX.lastIndex = 0;
  let array: RegExpExecArray | null;
  while ((array = KEYWORD_REGEX.exec(content)) !== null) {
    if (array.length >= 3) {
      const attr = array[1] ?? '';
      const foundName = KEYWORD_NAME_REGEX.exec(attr)?.[1] ?? '';
      if (foundName === name) return array[2];
    }
  }
  return null;
};

export const writeFile = async (
  filePath: string,
  content: string,
  rootDir: string
): Promise<void> => {
  if (rootDir) {
    await ensureSettingDirExists(rootDir);
  }
  const nextContent = await injectAutoGeneratedKeywordNames(content, rootDir);
  await writeFileRaw(filePath, nextContent);

  await extractAndSaveKeywords(filePath, nextContent, rootDir);
};

export const createFile = async (filePath: string): Promise<void> => {
  try {
    const exists = await fs
      .access(filePath)
      .then(() => true)
      .catch(() => false);
    if (exists) throw new Error('already exists');
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, FILE_TEMPLATE, 'utf-8');
  } catch (err) {
    console.error('error writing file: ', err);
    throw new Error('error writing file');
  }
};

export const createDirectory = async (dirPath: string): Promise<void> => {
  try {
    const exists = await fs
      .access(dirPath)
      .then(() => true)
      .catch(() => false);
    if (exists) throw new Error('already exists');
    await fs.mkdir(dirPath, { recursive: true });
  } catch (err) {
    console.error('error creating directory: ', err);
    throw new Error('error creating directory');
  }
};

export const deleteFile = async (filePath: string, rootDir: string): Promise<void> => {
  try {
    const stat = await fs.stat(filePath);
    if (stat.isDirectory()) {
      throw new Error('path is directory');
    }

    await fs.unlink(filePath);
    await removePathFromSession(rootDir, filePath);
    await removePathFromKeywords(rootDir, filePath);
  } catch (err) {
    console.error('error deleting file: ', err);
    throw new Error('error deleting file');
  }
};

export const renamePath = async (
  oldPath: string,
  newPath: string,
  rootDir: string
): Promise<void> => {
  try {
    const exists = await fs
      .access(newPath)
      .then(() => true)
      .catch(() => false);
    if (exists) throw new Error('already exists');

    await fs.mkdir(path.dirname(newPath), { recursive: true });
    await fs.rename(oldPath, newPath);

    await replacePathInSession(rootDir, oldPath, newPath);
    await replacePathInKeywords(rootDir, oldPath, newPath);
  } catch (err) {
    console.error('error renaming path: ', err);
    throw new Error('error renaming path');
  }
};

export const saveSession = async (rootDir: string, filePaths: string[]): Promise<void> => {
  await ensureSettingDirExists(rootDir);
  await writeFileRaw(sessionFilePath(rootDir), JSON.stringify(filePaths));
};

export const loadSession = async (rootDir: string): Promise<string[]> => {
  if (rootDir == '') {
    return [];
  }

  const filePaths: string[] = JSON.parse(await readFile(sessionFilePath(rootDir)));
  return filePaths;
};

export const loadKeywords = async (rootDir: string): Promise<Record<string, string>> => {
  if (rootDir == '') {
    return {};
  }

  const keywords: Record<string, string> = JSON.parse(await readFile(keywordsFilePath(rootDir)));
  return keywords;
};

export const saveProjectConfig = async (rootDir: string, config: ProjectConfig): Promise<void> => {
  await ensureSettingDirExists(rootDir);
  await writeFileRaw(settingsFIlePath(rootDir), JSON.stringify(config));
};

export const loadProjectConfig = async (rootDir: string): Promise<ProjectConfig> => {
  const config = await readFile(settingsFIlePath(rootDir));
  return JSON.parse(config);
};

const ensureSettingDirExists = async (rootDir: string): Promise<void> => {
  await fs.mkdir(path.join(rootDir, SETTINGS_DIR_PATH), { recursive: true });
};

const sessionFilePath = (rootDir: string): string =>
  path.join(rootDir, SETTINGS_DIR_PATH, SESSION_FILE_NAME);
const keywordsFilePath = (rootDir: string): string =>
  path.join(rootDir, SETTINGS_DIR_PATH, KEYWORDS_FILE_NAME);
const settingsFIlePath = (rootDir: string): string =>
  path.join(rootDir, SETTINGS_DIR_PATH, SETTINGS_FILE_NAME);
const latestFilePath = (rootDir: string): string =>
  path.join(rootDir, SETTINGS_DIR_PATH, LATEST_FILE_NAME);

const writeFileRaw = async (filePath: string, content: string): Promise<void> => {
  try {
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, content, 'utf-8');
  } catch (err) {
    console.error('error writing file: ', err);
    throw new Error('error writing file');
  }
};

const readJsonFileOrDefault = async <T>(filePath: string, defaultValue: T): Promise<T> => {
  try {
    const raw = await fs.readFile(filePath, 'utf-8');
    return JSON.parse(raw) as T;
  } catch {
    return defaultValue;
  }
};

const removePathFromSession = async (rootDir: string, targetPath: string): Promise<void> => {
  if (!rootDir) return;
  await ensureSettingDirExists(rootDir);
  const filePath = sessionFilePath(rootDir);
  const paths = await readJsonFileOrDefault<string[]>(filePath, []);
  const next = paths.filter((p) => p !== targetPath);
  await writeFileRaw(filePath, JSON.stringify(next));
};

const replacePathInSession = async (
  rootDir: string,
  oldPath: string,
  newPath: string
): Promise<void> => {
  if (!rootDir) return;
  await ensureSettingDirExists(rootDir);
  const filePath = sessionFilePath(rootDir);
  const paths = await readJsonFileOrDefault<string[]>(filePath, []);
  const next = paths.map((p) => (p === oldPath ? newPath : p));
  await writeFileRaw(filePath, JSON.stringify(next));
};

const removePathFromKeywords = async (rootDir: string, targetPath: string): Promise<void> => {
  if (!rootDir) return;
  await ensureSettingDirExists(rootDir);
  const filePath = keywordsFilePath(rootDir);
  const keywords = await readJsonFileOrDefault<Record<string, string>>(filePath, {});
  for (const [key, value] of Object.entries(keywords)) {
    if (value === targetPath) delete keywords[key];
  }
  await writeFileRaw(filePath, JSON.stringify(keywords));
};

const replacePathInKeywords = async (
  rootDir: string,
  oldPath: string,
  newPath: string
): Promise<void> => {
  if (!rootDir) return;
  await ensureSettingDirExists(rootDir);
  const filePath = keywordsFilePath(rootDir);
  const keywords = await readJsonFileOrDefault<Record<string, string>>(filePath, {});
  for (const [key, value] of Object.entries(keywords)) {
    if (value === oldPath) keywords[key] = newPath;
  }
  await writeFileRaw(filePath, JSON.stringify(keywords));
};

const extractAndSaveKeywords = async (
  filePath: string,
  content: string,
  rootDir: string
): Promise<void> => {
  await ensureSettingDirExists(rootDir);

  let keywords: Record<string, string>;
  try {
    const raw = await fs.readFile(keywordsFilePath(rootDir), 'utf-8');
    keywords = JSON.parse(raw);
  } catch {
    keywords = {};
  }

  for (const [key, value] of Object.entries(keywords)) {
    if (value == filePath) {
      delete keywords[key];
    }
  }

  KEYWORD_REGEX.lastIndex = 0;
  let array: RegExpExecArray | null;
  while ((array = KEYWORD_REGEX.exec(content)) !== null) {
    if (array.length > 1) {
      if (array[1].includes('noindex')) {
        continue;
      }
      const name = await getKeywordName(array[1], rootDir);
      if (name === '') {
        continue;
      }
      keywords[name] = filePath;
    }
  }

  await writeFileRaw(keywordsFilePath(rootDir), JSON.stringify(keywords));
};

const ensureLeadingSpace = (attr: string): string => {
  if (attr === '') return '';
  return /^\s/.test(attr) ? attr : ` ${attr}`;
};

const appendAttribute = (attr: string, fragment: string): string => {
  const normalized = ensureLeadingSpace(attr);
  const spacer = normalized === '' || /\s$/.test(normalized) ? '' : ' ';
  return `${normalized}${spacer}${fragment}`;
};

const escapeAttributeValue = (value: string): string => value.replaceAll('"', '&quot;');

const injectAutoGeneratedKeywordNames = async (
  content: string,
  rootDir: string
): Promise<string> => {
  const keywordTagRegex = /<keyword([\s\S]*?)>([\s\S]*?)<\/keyword>/g;

  let result = '';
  let lastIndex = 0;
  let match: RegExpExecArray | null;
  while ((match = keywordTagRegex.exec(content)) !== null) {
    const whole = match[0];
    const attr = match.length > 1 ? (match[1] ?? '') : '';
    const inner = match.length > 2 ? (match[2] ?? '') : '';

    result += content.slice(lastIndex, match.index);

    let nextAttr = ensureLeadingSpace(attr);
    if (!KEYWORD_NAME_REGEX.test(nextAttr)) {
      const name = await getKeywordName(nextAttr, rootDir);
      if (name !== '') {
        nextAttr = appendAttribute(nextAttr, `name="${escapeAttributeValue(name)}"`);
      }
    }

    const rebuilt = `<keyword${nextAttr}>${inner}</keyword>`;
    result += rebuilt;
    lastIndex = match.index + whole.length;
  }

  result += content.slice(lastIndex);
  return result;
};

const readLatest = async (rootDir: string): Promise<Record<string, number>> => {
  const filePath = latestFilePath(rootDir);

  await ensureSettingDirExists(rootDir);
  return await readJsonFileOrDefault<Record<string, number>>(filePath, {});
};

const updateLatest = async (rootDir: string, key: string, value: number): Promise<void> => {
  const filePath = latestFilePath(rootDir);
  const latests = await readLatest(rootDir);

  latests[key] = value;
  await fs.writeFile(filePath, JSON.stringify(latests));
};

const getKeywordName = async (attr: string, rootDir: string): Promise<string> => {
  const name = KEYWORD_NAME_REGEX.exec(attr);
  if (name !== null && name.length > 1) {
    return name[1];
  }

  const numberClass = KEYWORD_NUMBER_CLASS_REGEX.exec(attr);
  if (numberClass !== null && numberClass.length > 1) {
    const prefixMatch = KEYWORD_PREFIX_REGEX.exec(attr);
    const prefix = prefixMatch !== null && prefixMatch.length > 1 ? prefixMatch[1] : '命題';

    const latest = await readLatest(rootDir);
    if (numberClass[1] in latest) {
      await updateLatest(rootDir, numberClass[1], latest[numberClass[1]] + 1);
      return `${prefix} ${numberClass[1]}.${latest[numberClass[1]] + 1}`;
    } else {
      await updateLatest(rootDir, numberClass[1], 1);
      return `${prefix} ${numberClass[1]}.1`;
    }
  }
  return '';
};
